---
title:  "简单介绍一个IOS的分发工具：IPAshare"
toc: true
date: 2023-06-10
tags: 
- 软件开发
categories: 
- 软件开发
---

IPAshare本质上就是利用ad-hoc手段分发软件，在有一定限制的前提绕过苹果商店和特定的证书限制发布。但是注意，它仅仅解决发布问题，而不是权限问题。

项目地址**[https://github.com/togettoyou/ipashare](https://github.com/togettoyou/ipashare)**

*本文内容大部分参考自[https://github.com/sunBob-2/super-signature](https://github.com/sunBob-2/super-signature)*
<!--more-->

# IPAshare的目的和实现逻辑

IPAshare本质上就是利用ad-hoc手段分发软件，在有一定限制的前提绕过苹果商店和特定的证书限制发布。但是注意，它仅仅解决发布问题，而不是权限问题。

ad-hoc这种分发方式本质上是为了测试使用的，一个证书下面绑定100个设备，在给用户安装前需要将用户设备的UDID（标识符）添加到你的列表中，所以，原本的ad-hoc来分发软件相当的不方便，IPAshare解决的问题就是这部分不方便的自动化，核心就是利用苹果官方的API对这一流程进行自动化。具体什么是ad-hoc，网上有很多相关的教程和博客，这里就不赘述了。

# IPAshare的关键动作

从使用者来说，有依次的动作：

1. 下载并安装mobileconfig
2. 重定向到软件下载页面
3. 安装并安装成功

从开发者的角度来看，依次有以下操作：

1. 添加开发者账户
2. 上传ipa文件
3. 利用mobileconfig添加用户的UDID到开发中心
4. 对ipa进行重签名生成新的IPA文件
5. 返回plist文件供用户安装新的IPA文件

其中开发者视角的3,4,5与使用者视角的1,2,3是相互交错重合的

# 几点细节

cert(certificates)和profile(provisioning profile)的创建是通过App Store Connect API申请创建的，创建后利用这些材料是使用zsign进行重签名，大致的命令如下：

```shell
zsign -c ios_development.pem -k ios.key -m 描述文件.mobileprovision  -o new.ipa Runner.ipa
```

重签名的时间点是在每次用户重定向到软件下载页面之后，也就是说每次用户下载都要进行重签名，为什么会这样？这是因为采用Ad-hoc做分发，需要用户的设备标识符，所以每个新用户下载软件都需要把用户的设备标识打包进新的ipa。而证书则不需要每次安装创建新的。

具体关于请求携带信息的格式以及响应的格式可以参考官方文档或者源码。profile是控制程序权限的重要工具，而profile本身并不是直接持有权限（entitlement），而是通过对应的bundleID中的capabilities来提供，IPAshare会默认使用wildcard(*)这一个bundleID来申请profile，这个bundleID是通配的，但是很多权限是无法设置的，因此如果在使用IPAshare的过程中，如果出现程序打不开，请去苹果开发者的页面检查对应的profile entitlement，很有可能是这个问题（我就踩的这个坑）。

另外，在添加开发者账户后，IPAshare会通过官方API生成一个development的证书（具体是apple development还是ios development我忘了），这个证书就是用于zsign重签的。而且这个证书只能申请两个（对于付费的开发者账户而言是这样的，其他的不清楚），所以IPAshare会检查这类证书在你账户中的数量，如果数量大于1，那么添加开发者账户这一操作就失败了，在这里添加的开发者信息和证书是两个概念，如果出现上述问题注意区别（这个坑我也踩了好久）。

# 软件的架构学习

IPAshare的后端采用go语言编写，前端则用到了vite。配合docker可以实现快速部署，但是如果不使用docker自行部署还是很费力的，一方面要部署后端服务器，一方面又要部署Web，还有就是让两者畅通通信。我之前写过一个web端管理iptables的程序，采用的方法是内嵌Web资源的方式，是一个解决方案，这种手段虽然不是前后端分离，但是完全可以应付这样的使用场景（只不过用户不方便修改前端代码，但是却更易部署，既然部署容易其实就代表用户代码自定义会更容易），即又要提供页面有要提供API。

顺带提一句，前端的工具是真的迭代迅速啊，我两三年没碰前端框架，都不知道出现了pnpm这样的工具。

关于后端，IPAshare是一个值得初学者参考的web后端。后端的分层相当清晰，主要分为以下几层：

- main方法：在main方法中，主要针对命令行参数以及程序配置进行处理，并启动web服务器功能
- 请求响应层：主要的面向对象是用户的请求，包含web后端常见的鉴权、日志、API文档管理和路由功能，其中很多功能都以中间件的形式存在
- 接口层：针对用户请求以及路由，接口层负责具体逻辑的分发
- 服务层：服务层是由一系列具体的单一服务所组成的，该服务有合理的颗粒度，职责单一，上面的接口层通过对服务层调用组合并加以适当的逻辑来完成特定的任务
- model层：model不是严格的遵循上下层的关系，针对静态类型语言，需要设置model层统一管理程序中的各种对象，当然，动态类型能用也尽可能使用，这带来的是代码的阅读性与一致性。几乎所有层都需引用model层
- dao层：dao是数据访问对象（Data Access Object）的缩写，主要服务数据的持久化并向外提供数据持久化的操作接口
- pkg层：很多复杂方法的封装如果写在服务层会显得缺乏颗粒度，因此采用pkg层，其实也就是所谓的utils。

大中规模的单体网站都可以采用这样的架构模式，很传统但值得学习。

# 总结

IPAshare这个软件实际用起来比想象的要简单很多，但是前提是用户需要知道IOS开发分发的很多基本概念。本文简单对IPAshare做了一个讲解，其中包括了很多自己踩的坑，当然都是因为IOS开发分发概念不熟悉导致的。

因为这些坑，我阅读程序部分源码，也因而学到了不少东西，非常感谢，也感谢程序作者以及库的作者能制作出予人便利的工具供大家使用。
